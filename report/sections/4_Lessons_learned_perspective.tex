\section{Lessons Learned Perspective}

\subsection{Evolution and Refactoring}
The ideal approach to refactoring the old application would be to analyse, divide and concur the old application into 
subtask and define the overall design of the new application and then start the refactoring process. However, we started
refactoring without having an idea of how the result/end system should be. Thus, the process became very unstructured. 
We have learned that this could have been avoided by better planning aided by e.g. a Kanban board. This caused the 
refactoring process to take longer than anticipated and left us behind schedule. An example can be seen in this
\href{https://github.com/organizationGB/DevOps/commit/7bbccc97d6d69e90724b00e93e92334210490085}{commit} which is from a 
branch we ended up not using. \\

After refactoring the evolution of our application started. Our problem in regards to planning persisted, we did manage
to divide tasks but aggregating them afterwards could be challenging both in terms of information sharing and merging 
code. The introduction of new technologies further complicate this process. Unfinished tasks from backlog, coupled
with a rapid expansion of the stack due to the exercises for the current week, resulted in a fractured team and
codebase. This could have been avoided with less time pressure and better planning.\\

From a retrospective we should have been more structural in terms of e.g. having a daily meeting every time we met to encourage 
information sharing such as what are you working on, what do you expect of today and how far are we in the total process
of reaching this week goal.

\subsection{Operation}

\subsection{Maintenance}

\subsection{DevOps style of work}
In the process of developing the MiniTwit project, we worked as a team to create an infrastructure that would support a DevOps style of work by enabling us 
to implement continuous integration and continuous delivery to reduce the impact of making large deployments infrequently. We strived to deploy a developed 
feature once it was completed and tested through our pipeline rather than waiting to combine several features to deploy. Our setup enabled us to deploy automatically
through GitHub Actions and thus avoid any manual interference.